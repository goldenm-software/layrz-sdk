name: "Lint check"

on:
  pull_request:
    branches: [ main, next, development ]
    types: [ opened, synchronize, reopened ]

permissions:
  contents: read
  pull-requests: write

jobs:
  lint-python:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4.1.1

      - name: Setup UV
        uses: astral-sh/setup-uv@v7
        with:
          working-directory: ./python
          cache-python: true
          enable-cache: true
          cache-dependency-glob: "uv.lock"

      - name: Install dependencies
        working-directory: ./python
        run: uv sync --frozen

      - name: Run lint checks
        working-directory: ./python
        run: uv run ruff check

      - name: Run Type checking
        working-directory: ./python
        run: uv run ty check

      - name: Run tests with coverage
        working-directory: ./python
        run: uv run pytest ./tests/ --cov=layrz_sdk --cov-report=term --cov-report=json:coverage.json

      - name: Upload Python coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: python-coverage
          path: python/coverage.json
          retention-days: 1

  lint-go:
    runs-on: ubuntu-latest
    steps:
      - name: Clone the code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v6
        with:
          go-version: '1.25.5'
          cache-dependency-path: go/go.sum

      - name: Run linter
        uses: golangci/golangci-lint-action@v8
        with:
          working-directory: ./go
          version: v2.8

      - name: Run tests with coverage
        working-directory: ./go
        run: |
          go test ./tests/ -v -coverprofile=coverage.out -coverpkg=./entities/,./types/,./enums/
          go tool cover -func=coverage.out > coverage-summary.txt

      - name: Upload Go coverage
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: go-coverage
          path: |
            go/coverage.out
            go/coverage-summary.txt
          retention-days: 1

  coverage-comment:
    needs: [lint-python, lint-go]
    if: always() && github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: Download Python coverage
        uses: actions/download-artifact@v4
        with:
          name: python-coverage
          path: python-coverage
        continue-on-error: true

      - name: Download Go coverage
        uses: actions/download-artifact@v4
        with:
          name: go-coverage
          path: go-coverage
        continue-on-error: true

      - name: Post coverage comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            let pythonSection = '> No Python coverage data available.\n';
            let goSection = '> No Go coverage data available.\n';

            // Parse Python coverage (JSON from pytest-cov)
            try {
              const raw = fs.readFileSync('python-coverage/coverage.json', 'utf8');
              const data = JSON.parse(raw);
              const totals = data.totals;
              const pct = totals.percent_covered.toFixed(1);
              const covered = totals.covered_lines;
              const missing = totals.missing_lines;
              const total = covered + missing;

              pythonSection = `| Metric | Value |\n|--------|-------|\n`;
              pythonSection += `| **Coverage** | **${pct}%** |\n`;
              pythonSection += `| Lines covered | ${covered} / ${total} |\n`;
              pythonSection += `| Lines missing | ${missing} |\n`;
            } catch (e) {
              core.warning(`Failed to parse Python coverage: ${e.message}`);
            }

            // Parse Go coverage (text summary from go tool cover -func)
            try {
              const raw = fs.readFileSync('go-coverage/coverage-summary.txt', 'utf8');
              const lines = raw.trim().split('\n');
              const totalLine = lines[lines.length - 1];
              const match = totalLine.match(/([\d.]+)%/);
              const goPct = match ? match[1] : 'N/A';

              goSection = `| Metric | Value |\n|--------|-------|\n`;
              goSection += `| **Coverage** | **${goPct}%** |\n`;
              goSection += `| Functions measured | ${lines.length - 1} |\n`;
            } catch (e) {
              core.warning(`Failed to parse Go coverage: ${e.message}`);
            }

            const body = [
              '## Test Coverage Report',
              '',
              '### Python',
              pythonSection,
              '### Go',
              goSection,
              '',
              '---',
              `*Generated by CI on ${new Date().toISOString().split('T')[0]}*`,
            ].join('\n');

            // Find existing comment to update (avoid spam on re-pushes)
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const marker = '## Test Coverage Report';
            const existing = comments.find(c =>
              c.user.type === 'Bot' && c.body.includes(marker)
            );

            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body,
              });
              core.info(`Updated existing coverage comment #${existing.id}`);
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body,
              });
              core.info('Created new coverage comment');
            }
